---
title: Flink入门实操
tags: Flink
---
## Flink入门实操

Flink是一个可扩展的流数据处理框架。通过这篇指导将会了解如何编写流处理数据仓库(scalable streaming ETL)、分析以及事件驱动程序。

通过这篇指导，将会了解以下关于Flink的技术实现：

* 流数据处理管道
* flink状态管理机制
* 利用活动时间持续计算正确的分析
* 在连续的流上构建事件处理驱动
* 具有一次语义的容错、有状态流处理

这篇指导聚焦于四个重要的概念：流数据的持续处理、事件时间、有状态的流处理、状态简要说明。

### 流处理

流是数据的自然形态(natural habitat)，无论是服务端的事件、证劵交易所的交易、传感器读取的数据，这些数据都作为流的一部分被创建。你可以在有界或者无界的流范围内组织处理，而所选择的每一种处理形式都具有巨大的重要意义。

![](../images/flink1.png)

**批处理有范围的数据流模式**：在这种模式下，你能够在产生结果之前引入所有的数据集，这意味着可以对数据排序、计算全局统计报告或生成总结所有输入的最终报告。

**流处理模式**：对于没有范围的流数据，应该在这些数据到来的时候持续处理。

在Flink中，这些流数据流(streaming dataflows)可以由用户定义的操作符进行转换。这些数据流形成以一个或多个以source开始且以一个或多个sink结束的有向图。

![](../images/flink2.svg)

通常，在编码转换和数据流操作之间的通信是一对一的。有时一个转换包含多个操作。

应用程序可能会使用来自**流源**(如消息队列和分布式日志，例如：Apache、Kafka、Kinesis)的数据。同时Flink可以处理来自不同源的有范围历史数据。通过Flink框架进行流处理的结果可以被发送到多种系统中作为sink连接。

![](../images/flink3.png)

### 并行数据流

Flink中的程序本质上是并行与分布式的。在执行期间，一个流(stream)具有一个或多个流分区，且一个操作任务具有一个或多个子任务。每一个子任务独立于其他的子任务在线程、容器、节点上执行。

运算符子任务的数量是该特定运算符的并行度。不同的操作符在相同的编码中可能具有不同的并行级别。

![](../images/parallel_dataflow.svg)

stream可以通过一对一的模式(或者转发模式、重新分配模式)在两个操作之间传输数据：

* one-to-one streams：维持流的分区不变以及元素的排序的特性(例如在上面图中的`Source`和`map()`运算之间)。这意味着map()的subtask[1]将会看到Source的subtask[1]生成的元素。
* redistributing streams：(像map()和key by/window之间以及keyby/window和sink之间一样)改变了流的分区。每一个**操作子任务**发送数据到不同**目标子任务**，这个过程取决于选择发送的传输路径。例如`keyBy()`(通过哈希key的值重新分配分区)，broadcase(),rebalance()(随机的方式重新分配分区)。在redistributing模式下，元素的排序只维持在每一对发送和接收的子任务当中，例如：map[1]和keyBy()/window()/apply()[2]之间。上面显示的keyBy/window和sink运算符之间的重新分配引入了关于不同键的聚合结果到达sink的顺序不确定性。

### 及时的流处理

对于大多数的流应用程序而言，能够使用用于处理实时数据的相同代码重新处理历史数据并产生确定性、一致的结果，这是非常有价值的。

注意事件发生的顺序，而不是它们被交付处理的顺序，并且能够推理一组事件何时完成也很重要。例如，考虑电子商务交易和金融交易中的一组事件。

对于及时的流处理的要求是：其可以使用记录在数据流中的事件时间来处理数据，而不是使用服务器的时钟时间。

### 有状态的流处理

Flink的应用程序是可以有状态的，这意味着，一个事件如何被处理将取决于在它之前发生的所有事件的累计影响。简单一点事件：累加；复杂一点的事件：欺诈检测模型的计算特征。

一个Flink应用并行运行在一个分布式系统上。在基于同一个给定的操作下的多个并行实例将会在不同的线程甚至不同的机器上独立执行。

一个有状态运算符的并行实例集合实际上是一个分片键值存储。每个并行实例负责处理特定key的事件，并且这些key的状态保存在本地。

下图显示一个作业在图中的前三个操作符上以2的并行度运行，并且在一个并行度为1的sink结束。第三个过程是有状态的，这里第二个操作正在和第三个操作进行网络的全连接，这样做是为了根据key对流进行分区，以便需要被处理的数据能够一起被处理。

![](../images/parallel-job.png)

在本地访问状态，有助于帮助Flink应用提高吞吐量和降低延迟。（可以考虑将状态保持在JVM heap，如果状态过大，可以存储在有效组织的磁盘数据结构中）

![](../images/local-state.png)

### 通过状态快照的容错

Flink通过状态快照(state snapshot)和流重播(streams replay)的连接提供容错(fault-tolerant)和消息的精确一次(exactly-once)。

这些state snapshot捕捉分布式管道的整个状态，将偏移量记录到输入队列中，以及在整个作业图中记录到该点为止由于摄取数据而产生的状态。当发生故障时，源被倒回，状态被恢复，并且重新开始处理。如上描述的这个过程的状态快照是异步捕获的，不会妨碍正在进行的处理。



---

asnychronous: 非共时的、不同时的

periodic: 间歇性的、周期性的

Incremental snapshots: 增量快照

