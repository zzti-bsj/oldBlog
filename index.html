<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Bsj&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Bsj&#39;s Blog">
<meta property="og:url" content="https://zzti-bsj.github.io/index.html">
<meta property="og:site_name" content="Bsj&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Shaojie">
<meta property="article:tag" content="IT">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Bsj's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Bsj&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zzti-bsj.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ETL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/ETL/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/ETL/">ETL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><p>ETL 是 extract-transform-load的缩写，用来描述将数据从来源端经过抽取、转换、加载至目的端的过程。是数据仓库有关的技术。</p>
<p>ETL是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业零散、标准不一的数据整合到一起，为企业的决策提供分析依据。ETL是BI(商业智能)的一个重要环节。</p>
<p>对于这种技术，一般常见的是ETL和ELT混合使用，通常越大量的数据、复杂的转换逻辑、目的端为较强运算能力的数据库，越偏向使用ELT，以便运用目的端数据库的平行处理能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/ETL/" data-id="ckr54x28s000135sceqq63zzz" data-title="ETL" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Open-Tech/" rel="tag">Open-Tech</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Flink 文件系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/Flink%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/Flink%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Flink文件系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flink-文件系统"><a href="#Flink-文件系统" class="headerlink" title="Flink 文件系统"></a>Flink 文件系统</h2><p>Flink通过文件系统来使用数据、持久化数据，主要运用文件系统的部分包括但不限于：</p>
<ul>
<li>应用程序的结果</li>
<li>容错</li>
<li>恢复</li>
</ul>
<p>用于特定文件的文件系统由其URI决定，例如：</p>
<ul>
<li>从本地文件系统引入文件：file:///home/user/test.txt</li>
<li>从指定的HDFS集群引入文件：hdfs://namenode:50010/data/user/text.txt</li>
</ul>
<blockquote>
<p>文件系统实例在每一个进程中初始化一次，然后被缓存，从而避免流创建时的配置开销并且强制执行一些约束，例如：连接限制 &amp; 流的限制</p>
</blockquote>
<h3 id="本地文件系统"><a href="#本地文件系统" class="headerlink" title="本地文件系统"></a>本地文件系统</h3><p>Flink已经为本地文件系统提供了内置支持，包括任何挂载在本地文件系统的NFS或SAN驱动器，在没有任何额外配置的情况下可以默认使用。本地文件系统的使用形式：<code>file://URI</code>的形式。</p>
<h3 id="可插入的文件系统"><a href="#可插入的文件系统" class="headerlink" title="可插入的文件系统"></a>可插入的文件系统</h3><p>目前Flink支持的一些流行的文件系统：</p>
<ul>
<li>local</li>
<li>Hadoop-compatible</li>
<li>Amazon S3</li>
<li>MapR FS</li>
<li>Aliyun OSS</li>
<li>Azure Blob Storage</li>
</ul>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/deployment/filesystems/plugins/">把FS当作插件使用(除了MapR FS)</a></p>
</blockquote>
<p>当使用这些文件系统的时候，首先把Flink中对应的jar包按照如下的方式，从Flink下的<code>opt</code>目录copy到Flink下的<code>plugins</code>中：</p>
<pre><code class="shell">mkdir ./plugins/s3-fs-hadoop
cp ./opt/flink-s3-fs-hadoop-1.13.0.jar ./plugins/s3-fs-hadoop/
</code></pre>
<p>Flink 1.9 版本中引入了文件系统的插件机制，以支持每个插件专用的 Java 类加载器，并摆脱类着色机制(shading mechanism)。Flink提到依然可以使用旧的机制把对应的jar包copy到<code>lib</code>目录中。然后要注意的是，s3的插件从1.10必须要通过插件机制（s3在1.10之后只支持copy到plugins目录中加载）来加载。（鼓励使用插件机制来加载对应的文件系统，将来的Flink版本将不再支持shading机制）</p>
<p>旧的方式不再有效，因为这些插件不再被shading（或者更具体地说，自 1.10 以来这些类没有重新定位）– 不太理解</p>
<h3 id="添加一个新的可插入文件系统"><a href="#添加一个新的可插入文件系统" class="headerlink" title="添加一个新的可插入文件系统"></a>添加一个新的可插入文件系统</h3><p>文件系统通过<code>org.apache.flink.core.fs.FileSystem</code>类表示，通过该类捕获访问和修改文件系统中的文件和对象的方法。</p>
<p>添加一个新的文件系统：</p>
<ul>
<li>添加文件系统的实现，所添加的类是<code>org.apache.flink.core.fs.FileSystem</code>的子类。</li>
<li>添加一个Factory来实例化该文件系统并声明FileSystem注册的方案，该Factory必须是<code>org.apache.flink.core.fs.FileSystemFactory</code>的子类</li>
<li>添加一个服务入口。创建一个包含文件系统工厂类的文件：<code>META-INF/services/org.apache.flink.core.fs.FileSystemFactory</code>(更多细节参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">Java Service Loader docs</a>)</li>
</ul>
<p>在插件加载期间，文件系统类将会通过专用的Java类加载器避免与其他插件以及Flink组件的类冲突。相同的类加载器将会被用于文件系统初始化以及系统操作调用时。</p>
<blockquote>
<p>需要强调的是：这意味着需要在新文件系统的实现中关闭<code>Thread.currentThread().getContextClassLoader()</code>加载器。</p>
</blockquote>
<h3 id="HDFS和它的其它实现"><a href="#HDFS和它的其它实现" class="headerlink" title="HDFS和它的其它实现"></a>HDFS和它的其它实现</h3><p>Flink在找不到文件系统时，将会回退到HDFS。所有的HDFS的类库都在classpth并且在Flink运行时HDFS自动保持可用。</p>
<p>通过这种方式，Flink支持所有通过<code>org.apache.hadoop.fs.FileSystem</code>接口实现的HDFS以及HCFS(Hadoop-compatible file system)。</p>
<ul>
<li>HDFS (tested)</li>
<li><a target="_blank" rel="noopener" href="http://alluxio.org/">Alluxio</a> (tested, see configuration specifics below)</li>
<li><a target="_blank" rel="noopener" href="http://www.xtreemfs.org/">XtreemFS</a> (tested)</li>
<li>FTP via <a target="_blank" rel="noopener" href="http://hadoop.apache.org/docs/r1.2.1/hftp.html">Hftp</a> (not tested)</li>
<li>HAR (not tested)</li>
<li>…</li>
</ul>
<p>Hadoop配置必须在<code>core-site.xml</code>文件中有一个用于<strong>所需文件系统</strong>实现的条目。See example for <strong><a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/deployment/filesystems/overview/#alluxio">Alluxio</a></strong>.</p>
<p>推荐使用Flink内置的文件系统，除非必要情况下需要添加新的文件系统。有些情况也可能使用HDFS，比如在使用HDFS文件系统存储yarn的资源时，通过Hadoop <code>core-site.xml</code>中的<code>fs.defaultFS</code>属性来配置。</p>
<h3 id="Alluxio"><a href="#Alluxio" class="headerlink" title="Alluxio"></a>Alluxio</h3><p>对于Alluxio的支持，在<code>core-site.xml</code>文件中添加如下配置：</p>
<pre><code class="xml">&lt;property&gt;
  &lt;name&gt;fs.alluxio.impl&lt;/name&gt;
  &lt;value&gt;alluxio.hadoop.FileSystem&lt;/value&gt;
&lt;/property&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/Flink%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" data-id="ckr54x28w000335scaaumecqc" data-title="Flink文件系统" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Flink入门实操" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/Flink%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/Flink%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/">Flink入门实操</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flink入门实操"><a href="#Flink入门实操" class="headerlink" title="Flink入门实操"></a>Flink入门实操</h2><p>Flink是一个可扩展的流数据处理框架。通过这篇指导将会了解如何编写流处理数据仓库(scalable streaming ETL)、分析以及事件驱动程序。</p>
<p>通过这篇指导，将会了解以下关于Flink的技术实现：</p>
<ul>
<li>流数据处理管道</li>
<li>flink状态管理机制</li>
<li>利用活动时间持续计算正确的分析</li>
<li>在连续的流上构建事件处理驱动</li>
<li>具有一次语义的容错、有状态流处理</li>
</ul>
<p>这篇指导聚焦于四个重要的概念：流数据的持续处理、事件时间、有状态的流处理、状态简要说明。</p>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>流是数据的自然形态(natural habitat)，无论是服务端的事件、证劵交易所的交易、传感器读取的数据，这些数据都作为流的一部分被创建。你可以在有界或者无界的流范围内组织处理，而所选择的每一种处理形式都具有巨大的重要意义。</p>
<p><img src="/images/flink1.png"></p>
<p><strong>批处理有范围的数据流模式</strong>：在这种模式下，你能够在产生结果之前引入所有的数据集，这意味着可以对数据排序、计算全局统计报告或生成总结所有输入的最终报告。</p>
<p><strong>流处理模式</strong>：对于没有范围的流数据，应该在这些数据到来的时候持续处理。</p>
<p>在Flink中，这些流数据流(streaming dataflows)可以由用户定义的操作符进行转换。这些数据流形成以一个或多个以source开始且以一个或多个sink结束的有向图。</p>
<p><img src="/images/flink2.svg"></p>
<p>通常，在编码转换和数据流操作之间的通信是一对一的。有时一个转换包含多个操作。</p>
<p>应用程序可能会使用来自<strong>流源</strong>(如消息队列和分布式日志，例如：Apache、Kafka、Kinesis)的数据。同时Flink可以处理来自不同源的有范围历史数据。通过Flink框架进行流处理的结果可以被发送到多种系统中作为sink连接。</p>
<p><img src="/images/flink3.png"></p>
<h3 id="并行数据流"><a href="#并行数据流" class="headerlink" title="并行数据流"></a>并行数据流</h3><p>Flink中的程序本质上是并行与分布式的。在执行期间，一个流(stream)具有一个或多个流分区，且一个操作任务具有一个或多个子任务。每一个子任务独立于其他的子任务在线程、容器、节点上执行。</p>
<p>运算符子任务的数量是该特定运算符的并行度。不同的操作符在相同的编码中可能具有不同的并行级别。</p>
<p><img src="/images/parallel_dataflow.svg"></p>
<p>stream可以通过一对一的模式(或者转发模式、重新分配模式)在两个操作之间传输数据：</p>
<ul>
<li>one-to-one streams：维持流的分区不变以及元素的排序的特性(例如在上面图中的<code>Source</code>和<code>map()</code>运算之间)。这意味着map()的subtask[1]将会看到Source的subtask[1]生成的元素。</li>
<li>redistributing streams：(像map()和key by/window之间以及keyby/window和sink之间一样)改变了流的分区。每一个<strong>操作子任务</strong>发送数据到不同<strong>目标子任务</strong>，这个过程取决于选择发送的传输路径。例如<code>keyBy()</code>(通过哈希key的值重新分配分区)，broadcase(),rebalance()(随机的方式重新分配分区)。在redistributing模式下，元素的排序只维持在每一对发送和接收的子任务当中，例如：map[1]和keyBy()/window()/apply()[2]之间。上面显示的keyBy/window和sink运算符之间的重新分配引入了关于不同键的聚合结果到达sink的顺序不确定性。</li>
</ul>
<h3 id="及时的流处理"><a href="#及时的流处理" class="headerlink" title="及时的流处理"></a>及时的流处理</h3><p>对于大多数的流应用程序而言，能够使用用于处理实时数据的相同代码重新处理历史数据并产生确定性、一致的结果，这是非常有价值的。</p>
<p>注意事件发生的顺序，而不是它们被交付处理的顺序，并且能够推理一组事件何时完成也很重要。例如，考虑电子商务交易和金融交易中的一组事件。</p>
<p>对于及时的流处理的要求是：其可以使用记录在数据流中的事件时间来处理数据，而不是使用服务器的时钟时间。</p>
<h3 id="有状态的流处理"><a href="#有状态的流处理" class="headerlink" title="有状态的流处理"></a>有状态的流处理</h3><p>Flink的应用程序是可以有状态的，这意味着，一个事件如何被处理将取决于在它之前发生的所有事件的累计影响。简单一点事件：累加；复杂一点的事件：欺诈检测模型的计算特征。</p>
<p>一个Flink应用并行运行在一个分布式系统上。在基于同一个给定的操作下的多个并行实例将会在不同的线程甚至不同的机器上独立执行。</p>
<p>一个有状态运算符的并行实例集合实际上是一个分片键值存储。每个并行实例负责处理特定key的事件，并且这些key的状态保存在本地。</p>
<p>下图显示一个作业在图中的前三个操作符上以2的并行度运行，并且在一个并行度为1的sink结束。第三个过程是有状态的，这里第二个操作正在和第三个操作进行网络的全连接，这样做是为了根据key对流进行分区，以便需要被处理的数据能够一起被处理。</p>
<p><img src="/images/parallel-job.png"></p>
<p>在本地访问状态，有助于帮助Flink应用提高吞吐量和降低延迟。（可以考虑将状态保持在JVM heap，如果状态过大，可以存储在有效组织的磁盘数据结构中）</p>
<p><img src="/images/local-state.png"></p>
<h3 id="通过状态快照的容错"><a href="#通过状态快照的容错" class="headerlink" title="通过状态快照的容错"></a>通过状态快照的容错</h3><p>Flink通过状态快照(state snapshot)和流重播(streams replay)的连接提供容错(fault-tolerant)和消息的精确一次(exactly-once)。</p>
<p>这些state snapshot捕捉分布式管道的整个状态，将偏移量记录到输入队列中，以及在整个作业图中记录到该点为止由于摄取数据而产生的状态。当发生故障时，源被倒回，状态被恢复，并且重新开始处理。如上描述的这个过程的状态快照是异步捕获的，不会妨碍正在进行的处理。</p>
<hr>
<p>asnychronous: 非共时的、不同时的</p>
<p>periodic: 间歇性的、周期性的</p>
<p>Incremental snapshots: 增量快照</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/Flink%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/" data-id="ckr54x28z000535sc84q49m97" data-title="Flink入门实操" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Flink文件系统 - 常用配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/Flink%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20-%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/Flink%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20-%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/">Flink文件系统-常用配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flink文件系统-常用配置"><a href="#Flink文件系统-常用配置" class="headerlink" title="Flink文件系统 - 常用配置"></a>Flink文件系统 - 常用配置</h2><p>Flink提供了多种跨所有文件系统的标准配置。</p>
<h3 id="默认的文件系统"><a href="#默认的文件系统" class="headerlink" title="默认的文件系统"></a>默认的文件系统</h3><p>如果文件路径没有显示地指定scheme/authoriy，那么将会使用默认的scheme/authoriy。</p>
<pre><code class="yaml">fs.default-scheme: &lt;default-fs&gt;
</code></pre>
<p>例如：如果一个默认的系统配置是：<code>fs.default-scheme: hdfs://localhost:9000/</code>，那么文件路径为<code>/user/in.txt</code>的文件路径将会被解释为：<code>hdfs://localhost:9000/user/in.txt</code>。</p>
<h3 id="连接限制"><a href="#连接限制" class="headerlink" title="连接限制"></a>连接限制</h3><p>为了限制文件系统的连接，可以在Flink的配置中添加如下条目：</p>
<pre><code class="yaml">fs.&lt;scheme&gt;.limit.total: (number, 0/-1 mean no limit)
fs.&lt;scheme&gt;.limit.input: (number, 0/-1 mean no limit)
fs.&lt;scheme&gt;.limit.output: (number, 0/-1 mean no limit)
fs.&lt;scheme&gt;.limit.timeout: (milliseconds, 0 means infinite)
fs.&lt;scheme&gt;.limit.stream-timeout: (milliseconds, 0 means infinite)
</code></pre>
<p>可以通过<code>fs.&lt;scheme&gt;.limit.input</code>和<code>fs.&lt;scheme&gt;.limit.output</code>来分别设置Flink的连接数，也可以通过<code>fs.&lt;scheme&gt;.limit.total</code>来限制文件流的连接总数，如果文件系统尝试更多的连接，那么这些连接操作将被阻塞直到其他的连接断开；某文件流的连接时长超过<code>fs.&lt;scheme&gt;.limit.timeout</code>限制的大小，将会连接失败。</p>
<p>为了防止无效流连接占满连接池，可以添加一个无效超时<code>fs.&lt;scheme&gt;.limit.stream-timeout</code>来关闭在这段时间内没有读/写任何字节的流连接。</p>
<p>这些限制基于每一个TaskManager/filesystem。因为文件系统的创建发生在每一个scheme/authority，所以不同的authorities拥有独立的连接池。例如：<code>hdfs://myhdfs:50010/</code> and <code>hdfs://anotherhdfs:4399/</code>将会具有不同的连接池。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/Flink%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20-%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" data-id="ckr54x290000635sc0ov1chne" data-title="Flink文件系统-常用配置" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Flink的三种模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/Flink%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/Flink%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/">Flink概览-three modes</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flink概览-three-mode"><a href="#Flink概览-three-mode" class="headerlink" title="Flink概览-three mode"></a>Flink概览-three mode</h2><p>Flink是一个具有多用途的框架，支持许多不同的部署场景。</p>
<p>接下来，将会短暂地介绍一个FLink集群的构成要素，以及它们的目标和可用的技术实现。</p>
<h3 id="概览和参考架构"><a href="#概览和参考架构" class="headerlink" title="概览和参考架构"></a>概览和参考架构</h3><p><img src="/images/deployment_overview.svg"></p>
<p>在Flink的集群中，总有一个client在运行。client获取应用程序的代码，并且将其转化成JobGraph提交给JobManager进行处理。</p>
<ul>
<li>JobManager: 将任务分布到TaskManager，TaskManager的主要任务就是来处理提交的任务，如下图的过程是在TaskManager中执行的。</li>
</ul>
<p><img src="/images/parallel_dataflow.svg"></p>
<table>
<thead>
<tr>
<th>Component</th>
<th align="left">Purpose</th>
<th>Implementations</th>
</tr>
</thead>
<tbody><tr>
<td>Flink Client</td>
<td align="left">将批处理或流应用程序编译成数据流图，然后提交到JobManager</td>
<td>command line nterface<br />REST Endpoint<br />SQL Client<br />Python REPL<br />Scala REPL</td>
</tr>
<tr>
<td>JobManager</td>
<td align="left">JobManager是Flink核心工作的协调组件，其具有对于不同资源提供者的实现方式，在HA、资源分配行为以及支持作业的提交模式上有所不同，用于提交Job的三种JobManager模式：1. Session mode 2. Application mode 3. Per-job mode</td>
<td>1. standalone(这种准系统模式只要求JVM能够运行。可以部署在多种环境下，如：k8s、Docker、non-native k8s等等)<br />2. Kubernetes<br />3. YARN<br />4. Mesos</td>
</tr>
<tr>
<td>TaskManager</td>
<td align="left">TaskManager负责真正的执行提交的Job</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Exeternal Components 暂时不更新</p>
</blockquote>
<h3 id="Flink的三种部署模式"><a href="#Flink的三种部署模式" class="headerlink" title="Flink的三种部署模式"></a>Flink的三种部署模式</h3><ul>
<li>session mode</li>
<li>application mode</li>
<li>per-job mode</li>
</ul>
<p>三种模式的不同在于：</p>
<ul>
<li>集群的生命周期和资源的隔离保证</li>
<li>Job的main()方法是在client端执行还是在Flink集群上执行</li>
</ul>
<p><img src="/images/deployment_modes.svg"></p>
<p>Application mode: 启动一个jobmanager执行任务；Flink applicaiton运行在jobmanager上。</p>
<p>Per-job mode: 启动一个jobmanager执行任务；Flink application运行在提交任务的集群client上。</p>
<p>Session mode: 多个任务共享一个jobmanager</p>
<h4 id="Application-mode"><a href="#Application-mode" class="headerlink" title="Application mode"></a>Application mode</h4><p>在<strong>其他两种模式中，应用程序的main()方法在client端执行</strong>。这个程序包括在本地下载应用程序的依赖，执行main()函数提取一个Flink运行时可以理解的表现形式(如JobGraph)，然后将依赖和JobGraph提交到集群。下载依赖、CPU执行main()的周期以及发送二进制数据到集群会给client端带来巨大的网络开销，当客户端在用户之间共享时，这个问题会更加明显。</p>
<p>基于这一观察，<strong>Application mode为每一个提交的应用程序创建一个集群，同时main()方法在JobManager上执行</strong>。为每个应用程序创建一个集群可以被看作：创建一个仅在特定应用程序的作业之间共享的会话集群，并在应用程序完成时拆除。在这种架构下，Application mode提供了与Per-job mode相同的资源隔离和负载均衡的保证（但是是以整个应用程序的颗粒进行资源隔离和负载均衡的保证）。在JobManager上执行main()可以节省所需的CPU执行周期以及本地下载依赖所需的带宽。因为每一个应用程序（每一个为应用程序创建的Flink集群）都有一个Jobmanager，所以它允许更均匀地分散网络负载以下载应用程序中的依赖项。</p>
<blockquote>
<p>在Application mode中，main()方法是在cluster上执行的，而不是在client端执行的。(与其他两种模式一样在cluster端执行)</p>
</blockquote>
<p>相比于Per-job mode，Application mode允许提交的应用程序中包含多个job。job的执行不受部署模式的影响，而是受启动作业的调用程序的影响。例如：使用<code>execut()</code>调用job，将会阻塞直到当前任务完成之后再调用下一个任务；使用<code>executeAsync()</code>调用job(异步任务)，将会在当前任务完成之前启动下一个任务。</p>
<blockquote>
<ol>
<li><p>Application mode允许多个execute()，但多exectue()不支持HA。HA在application mode下只支持单个execute()</p>
</li>
<li><p>当Application mode下的多个正在运行的作业(例如executeAsync()提交的多个job)中的任何一个被取消时，所有作业都将停止并且Jobmanager将会关闭。支持定期作业完成(通过源关闭)</p>
</li>
</ol>
</blockquote>
<h3 id="Per-job-mode"><a href="#Per-job-mode" class="headerlink" title="Per-job mode"></a>Per-job mode</h3><p>Per-job mode意在提供更好的资源隔离的保证。Per-job使用可利用的资源提供者框架为每一个提交的job创建一个集群，这个被创建的集群只为提交的这个job可用。当且仅当这个Job执行完成之后，这个集群将会被拆除，并且分配的资源被清理。这提供了更好的资源隔离，因为异常的Job只能关闭它的TaskManager。此外，它将book-keeping(一些元数据的记录)分配到每一个Jobmanager中，由于这个原因，Per-job mode资源分配模型是许多生产原因的首选模式。</p>
<h3 id="Session-mode"><a href="#Session-mode" class="headerlink" title="Session mode"></a>Session mode</h3><p>Session mode假定已经存在一个正在运行的Flink集群，并且使用该集群中的资源去执行任何被提交的应用程序。在同一Session mode集群中执行的应用程序竞争资源使用。这样做的好处是不用为每个提交的Job创建集群而花费资源开销。但坏处是，如果有一个Job异常并且关闭了Taskmanager，那么在这个Taskmanager上运行的所有Job将会失败。除了可能会导致作业失败之外，还意味着具有潜在的大规模恢复过程，所有重新启动的任务同时访问文件系统而导致其他服务无法使用该文件系统。此外，让单个集群运行多个作业，意味着Jobmanager的负载更大，后者负责集群中所有作业的book-keeping。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Session mode中，集群的生命周期独立于任何运行在集群上的Job，并且资源在所有Job之间共享。</p>
<p>在Per-job mode中，为每一个提交的job花费开销创建集群，达到了资源隔离的目的。在这种模式下，集群的生命周期与Job绑定。</p>
<p>在Application mode中，为每一个应用程序创建一个Session集群，并且在cluster(Jobmanager)上执行<code>main()</code>方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/Flink%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/" data-id="ckr54x291000735scep816j7e" data-title="Flink概览-three modes" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-[Hexo] 设置标签" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/%5BHexo%5D%20%E8%AE%BE%E7%BD%AE%E6%A0%87%E7%AD%BE/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/%5BHexo%5D%20%E8%AE%BE%E7%BD%AE%E6%A0%87%E7%AD%BE/">在博客的根目录下创建tags目录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="在博客的根目录下创建tags目录"><a href="#在博客的根目录下创建tags目录" class="headerlink" title="在博客的根目录下创建tags目录"></a>在博客的根目录下创建tags目录</h2><ol>
<li>创建tags目录</li>
</ol>
<p><code>hexo new page tags</code></p>
<ol start="2">
<li><p>设置tags/index.html</p>
<p>在index.html中加上type: “tags”</p>
<pre><code class="shell">---
title: tags
date: 2021-07-06 23:44:14
type: &quot;tags&quot;
---
</code></pre>
</li>
</ol>
<h2 id="创建categories目录"><a href="#创建categories目录" class="headerlink" title="创建categories目录"></a>创建categories目录</h2><p>同创建tags目录的方式一样，把关键字tags换成categories即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/[Hexo]%20%E8%AE%BE%E7%BD%AE%E6%A0%87%E7%AD%BE/" data-id="ckr54x292000a35scertt0z16" data-title="在博客的根目录下创建tags目录" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T16:36:25.365Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/hello-world/" data-id="ckr54x294000b35sc209a0dph" data-title="Hello World" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-shell 语法基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/shell%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T00:00:00.000Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/shell%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/">shell 语法基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="shell-语法基础"><a href="#shell-语法基础" class="headerlink" title="shell 语法基础"></a>shell 语法基础</h2><p>简单来说一下shell是什么：shell是基于C写的一个程序，因为确实是用C语言实现的东西。同时shell是命令语言，众所周知，在linux命令行下执行的命令一般都是shell命令。同时shell是一种编程语言，这更好理解，通过与其他编程语言对比就可以知道，shell也可以通过编写程序实现所需的功能。</p>
<blockquote>
<p>Shell 和 Shell脚本并不相同，Shell脚本是通过Shell实现的程序文件</p>
</blockquote>
<p>接下来就不啰嗦，直接尽可能的精简去认识shell的语法。</p>
<ul>
<li><p>hello world</p>
<ul>
<li>echo 打印内容</li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li>如何定义变量</li>
<li>如何使用变量</li>
<li>只读变量</li>
<li>删除变量</li>
</ul>
</li>
<li><p>字符串：单引号和双引号的区别</p>
<ul>
<li>单引号变量</li>
<li>双引号变量</li>
<li>获取字符串长度</li>
<li>截取子字符串</li>
<li>查询字符在字符串中的位置</li>
</ul>
</li>
</ul>
<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>关键字<code>echo</code>：打印内容   </p>
<p>输出<code>hello world</code></p>
<pre><code class="shell">echo &quot;hello world&quot;
</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>shell中提到的三种变量：</p>
<ul>
<li>局部变量：在脚本或命令中定义，生命周期只在其定义的实例中有效。</li>
<li>环境变量：系统的环境变量</li>
<li>shell变量：就。。。扯淡，不就是变量的统称？！</li>
</ul>
<p>与其他编程语言对变量合法性的要求相同，不能包含特殊字符，只能由下划线、数字、字母，首字母不能以数字开头。  </p>
<p><strong>定义变量：</strong></p>
<pre><code class="shell">my_blog=&quot;shell language&quot;
</code></pre>
<p>等号与左边的变量以及右边的值之间都不能有空格！</p>
<p><strong>使用变量</strong>：</p>
<pre><code class="shell">echo $&#123;my_blog&#125;    
</code></pre>
<p>输出的结果是<code>shell language</code></p>
<blockquote>
<p>使用花括号引着变量更规范，不必要时可以不加{}</p>
</blockquote>
<p>只读变量：</p>
<pre><code class="shell">my_name=&quot;soro&quot;
readonly my_name
</code></pre>
<p>在定义变量之后，使用<code>readonly</code>标记变量为只读变量，该变量在之后如果尝试被修改则会报错，避免了重要的变量内容被覆盖！</p>
<p>删除变量：</p>
<pre><code class="shell">unset my_name
</code></pre>
<blockquote>
<p>注意：对变量的<strong>非读写</strong>操作unset和readonly后，只跟变量名，没有$符号。</p>
</blockquote>
<h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p><strong>单引号字符串</strong></p>
<ul>
<li>字符串内容原样输出</li>
<li>单引号中可以包含多对单引号，不能只出现一个单引号</li>
</ul>
<pre><code class="shell">my_name=&#39;bai&#39;shao&#39;jie&#39;
echo $my_name
</code></pre>
<p>输出结果是<code>baishaojie</code></p>
<p><strong>双引号字符串</strong></p>
<ul>
<li>在双引号中的变量以及特殊字符可以被转义输出</li>
<li>在单引号中如果要转义，需要用单引号拼接！</li>
</ul>
<pre><code class="shell"># 单引号中转义
name=&#39;shaojie&#39;
my_name=&#39;bai&#39;$name&#39;&#39;

# 双引号中
name=&#39;shaojie&#39;
my_name=&#39;bai$&#123;name&#125;&#39;
</code></pre>
<p><strong>获取字符串长度 &amp; 提取子字符串</strong></p>
<pre><code class="shell"># 获取字符串长度
string=&#39;abcd&#39;
str_len=$&#123;#string&#125;
echo $str_len

# 提取子字符串
string=&#39;this is an apple&#39;
substr=$&#123;string:1:4&#125;
echo $substr
substr_len=$&#123;#substr&#125;
echo $substr_len

# $str_len: 4
# $substr: &#39;his &#39;   
# $substr_len: 4
</code></pre>
<p><strong>查找字符位置</strong></p>
<pre><code class="shell"># 查找 i/o 字符在$string中的位置，输出的位置下标值是最先被找到的字符的位置！
string=&#39;this is an apple&#39;
echo `expr index &quot;$string&quot; io`
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzti-bsj.github.io/2021/07/15/shell%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" data-id="ckr54x296000d35scdnwp5kcq" data-title="shell 语法基础" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/" rel="tag">shell</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/" rel="tag">Flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Open-Tech/" rel="tag">Open-Tech</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Flink/" style="font-size: 20px;">Flink</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Open-Tech/" style="font-size: 10px;">Open-Tech</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/15/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2021/07/15/Flink%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Flink文件系统</a>
          </li>
        
          <li>
            <a href="/2021/07/15/Flink%E5%85%A5%E9%97%A8%E5%AE%9E%E6%93%8D/">Flink入门实操</a>
          </li>
        
          <li>
            <a href="/2021/07/15/Flink%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20-%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/">Flink文件系统-常用配置</a>
          </li>
        
          <li>
            <a href="/2021/07/15/Flink%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/">Flink概览-three modes</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Shaojie<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>